---
import { Image } from 'astro:assets';
import { getCollection } from 'astro:content';
import BaseHead from '../../components/BaseHead.astro';
import Footer from '../../components/Footer.astro';
import FormattedDate from '../../components/FormattedDate.astro';
import Header from '../../components/Header.astro';
import { SITE_DESCRIPTION, SITE_TITLE, TAG_COLORS } from '../../consts';

const posts = (await getCollection('blog')).sort(
	(a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf(),
);

const allTags = Array.from(
	new Set(
		posts
			.flatMap((post) => post.data.tags ?? [])
			.map((tag) => tag.trim())
			.filter(Boolean)
			.map((tag) => tag.toLowerCase()),
	),
).sort((a, b) => a.localeCompare(b));
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
		<style>
			main {
				width: 100%;
				max-width: 1200px;
				margin: 0 auto;
				padding: 0 1rem 4rem 1rem;
			}
			.layout {
				position: relative;
				max-width: 720px;
				margin: 0 auto;
			}
			.posts {
				width: 100%;
			}
			.sidebar {
				position: absolute;
				left: 100%;
				top: 0;
				width: 240px;
				margin-left: 2rem;
				padding: 1rem 0;
			}
			.sidebar fieldset {
				border: none;
				padding: 0;
				margin: 0;
			}
			.sidebar legend {
				font-weight: 700;
				margin-bottom: 0.5rem;
			}
			.tag-list {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
				margin-top: 0.75rem;
			}
			.tag-item {
				display: inline-flex;
				align-items: center;
				padding: 0.5em 1em;
				background-color: rgba(var(--gray), 0.15);
				border-radius: 2em;
				cursor: pointer;
				transition: all 0.2s ease;
				font-size: 0.9em;
				user-select: none;
				color: rgb(var(--gray-dark));
				border: 1px solid transparent;
			}
			.tag-item:hover {
				background-color: rgba(var(--gray), 0.25);
			}
			.tag-item.selected {
				background-color: rgba(59, 130, 246, 0.15);
				color: rgb(37, 99, 235);
				border-color: rgba(59, 130, 246, 0.3);
			}
			.tag-item input {
				display: none;
			}
			.tag-empty {
				color: rgb(var(--gray));
				font-style: italic;
				margin-top: 0.75rem;
			}
			ul {
				display: flex;
				flex-wrap: wrap;
				gap: 2rem;
				list-style-type: none;
				margin: 0;
				padding: 0;
			}
			ul li {
				width: calc(50% - 1rem);
				height: 250px;
				border-radius: 12px;
				overflow: hidden;
				transition: all 0.2s ease;
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
			}
			ul li:hover {
				transform: translateY(-4px);
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			}
			ul li:first-child {
				width: 100%;
				margin-bottom: 1rem;
			}
			ul li a {
				display: block;
				height: 100%;
				text-decoration: none;
				position: relative;
			}
			.card-bg-image {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
				z-index: 0;
			}
			.card-content {
				position: relative;
				z-index: 1;
				height: 100%;
				padding: 1.5rem;
				display: flex;
				flex-direction: column;
				color: white;
			}
			.card-content.has-image {
				justify-content: flex-end;
				background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 50%, transparent 100%);
			}
			.card-content.no-image {
				justify-content: center;
				align-items: center;
				text-align: center;
			}
			.title {
				margin: 0 0 0.5rem 0;
				color: white;
				line-height: 1.2;
				font-size: 1.5rem;
				text-shadow: 0 1px 3px rgba(0,0,0,0.8), 0 2px 10px rgba(0,0,0,0.5);
			}
			.date {
				margin: 0;
				color: rgba(255, 255, 255, 0.9);
				font-size: 0.9rem;
				text-shadow: 0 1px 3px rgba(0,0,0,0.8), 0 2px 10px rgba(0,0,0,0.5);
			}
			ul li:first-child .title {
				font-size: 2.5rem;
			}
			@media (max-width: 720px) {
				.layout {
					/* flex-direction: column; */
				}
				.sidebar {
					width: 100%;
					position: static;
					margin-left: 0;
				}
				ul {
					gap: 1rem;
				}
				ul li {
					width: 100%;
				}
				ul li:first-child .title {
					font-size: 1.8rem;
				}
			}
		</style>
	</head>
	<body>
		<Header />
		<main>
			<div class="layout">
				<section class="posts">
					<ul id="post-list">
						{
							posts.map((post) => {
								const tags = (post.data.tags ?? [])
									.map((t) => t.trim())
									.filter(Boolean)
									.map((t) => t.toLowerCase());
								
								const firstTag = tags[0] || 'default';
								const bgColor = TAG_COLORS[firstTag] || TAG_COLORS['default'];

								return (
									<li data-tags={tags.join('|')} data-id={post.id} style={`background-color: ${bgColor}`}>
										<a href={`/blog/${post.id}/`}>
											{post.data.heroImage && (
												<Image width={720} height={360} src={post.data.heroImage} alt="" class="card-bg-image" />
											)}
											<div class={`card-content ${post.data.heroImage ? 'has-image' : 'no-image'}`}>
												<h4 class="title">{post.data.title}</h4>
												<p class="date">
													<FormattedDate date={post.data.pubDate} />
												</p>
											</div>
										</a>
									</li>
								);
							})
						}
					</ul>
				</section>

				<aside class="sidebar" aria-label="Tag filter">
					<form id="tag-filter">
						<fieldset>
							<legend>Tags</legend>
							{allTags.length === 0 ? (
								<p class="tag-empty">No tags</p>
							) : (
								<div class="tag-list">
									{
										allTags.map((tag) => (
											<label class="tag-item">
												<input type="checkbox" name="tags" value={tag} />
												<span>{tag}</span>
											</label>
										))
									}
								</div>
							)}
						</fieldset>
					</form>
				</aside>
			</div>
		</main>
		<Footer />
		<script>
			(() => {
				const form = document.getElementById('tag-filter');
				const list = document.getElementById('post-list');
				if (!(form instanceof HTMLFormElement) || !(list instanceof HTMLElement)) return;

				const items = Array.from(list.querySelectorAll('li'));
				
				/** @type {Set<string> | null} */
				let searchResults = null;
				/** @type {Array<{id: string, title: string, body: string, tags: string[]}> | null} */
				let searchIndex = null;

				const getSelected = () => {
					const checked = Array.from(form.querySelectorAll('input[name="tags"]:checked'));
					return new Set(
						checked
							.filter((el) => el instanceof HTMLInputElement)
							.map((el) => el.value),
					);
				};

				const apply = () => {
					const selected = getSelected();

					// Update visual state
					const inputs = form.querySelectorAll('input[name="tags"]');
					inputs.forEach((input) => {
						const label = input.closest('.tag-item');
						if (label) {
							if (input instanceof HTMLInputElement && input.checked) {
								label.classList.add('selected');
							} else {
								label.classList.remove('selected');
							}
						}
					});

					const hasTagFilter = selected.size > 0;
					const hasSearchFilter = searchResults !== null;

					for (const li of items) {
						if (!(li instanceof HTMLLIElement)) continue;
						
						let matches = true;

						if (hasTagFilter) {
							const tagAttr = li.getAttribute('data-tags') ?? '';
							const postTags = new Set(tagAttr.split('|').filter(Boolean));
							for (const t of selected) {
								if (!postTags.has(t)) {
									matches = false;
									break;
								}
							}
						}

						if (matches && hasSearchFilter) {
							const id = li.getAttribute('data-id');
							if (!id || !searchResults.has(id)) {
								matches = false;
							}
						}

						li.style.display = matches ? '' : 'none';
					}
				};

				form.addEventListener('change', apply);

				const loadSearchIndex = async () => {
					if (searchIndex) return searchIndex;
					try {
						const res = await fetch('/search.json');
						if (!res.ok) {
							throw new Error(`HTTP error! status: ${res.status}`);
						}
						searchIndex = await res.json();
						console.log('Search index loaded:', searchIndex.length, 'items');
						return searchIndex;
					} catch (e) {
						console.error('Failed to load search index', e);
						return [];
					}
				};

				const performSearch = async (query) => {
					if (!query) {
						searchResults = null;
						apply();
						return;
					}
					
					const index = await loadSearchIndex();
					const q = query.toLowerCase();
					searchResults = new Set();
					
					for (const post of index) {
						const title = post.title ? post.title.toLowerCase() : '';
						const body = post.body ? post.body.toLowerCase() : '';
						if (title.includes(q) || body.includes(q)) {
							searchResults.add(post.id);
						}
					}
					apply();
				};

				window.addEventListener('search-updated', (e) => {
					if (e instanceof CustomEvent) {
						performSearch(e.detail.query);
					}
				});

				const urlParams = new URLSearchParams(window.location.search);
				const q = urlParams.get('q');
				if (q) {
					performSearch(q);
				} else {
					apply();
				}
			})();
		</script>
	</body>
</html>
